/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

% # Copyright (c) 2018 Takashi Kokubun.  All rights reserved.
% #
% # This file is a part of  the programming language Ruby.  Permission is hereby
% # granted, to either  redistribute and/or modify this file,  provided that the
% # conditions mentioned  in the  file COPYING  are met.   Consult the  file for
% # details.
<%= render 'copyright' %>
%
% # This is an ERB template that generates Ruby code that generates C code that
% # generates JIT-ed C code.
<%= render 'notice', locals: {
    this_file: 'is the main part of compile_insn() in mjit_compile.c',
    edit: __FILE__,
} -%>
%
% unsupported_insns = [
%   'getblockparamproxy',  # TODO: support this
%   'defineclass',         # low priority
%   'opt_call_c_function', # low priority
% ]
%
% opt_send_without_block = RubyVM::Instructions.find { |i| i.name == 'opt_send_without_block' }
% if opt_send_without_block.nil?
%   raise 'opt_send_without_block not found'
% end
%
% # Available variables and macros in JIT-ed function:
% #   ec: the first argument of _mjitXXX
% #   reg_cfp: the second argument of _mjitXXX
% #   GET_CFP(): refers to `reg_cfp`
% #   GET_EP(): refers to `reg_cfp->ep`
% #   GET_SP(): refers to `reg_cfp->sp`, or `(stack + stack_size)` if local_stack_p
% #   GET_SELF(): refers to `reg_cfp->self`
% #   GET_LEP(): refers to `VM_EP_LEP(reg_cfp->ep)`
% #   EXEC_EC_CFP(): refers to `val = vm_exec(ec, TRUE)` with frame setup
% #   CALL_METHOD(): using `GET_CFP()` and `EXEC_EC_CFP()`
% #   TOPN(): refers to `reg_cfp->sp`, or `*(stack + (stack_size - num - 1))` if local_stack_p
% #   STACK_ADDR_FROM_TOP(): refers to `reg_cfp->sp`, or `stack + (stack_size - num)` if local_stack_p
% #   DISPATCH_ORIGINAL_INSN(): expanded in _mjit_compile_insn.erb
% #   THROW_EXCEPTION(): specially defined for JIT
% #   RESTORE_REGS(): specially defined for `leave`

switch (insn) {
% (RubyVM::BareInstructions.to_a + RubyVM::OperandsUnifications.to_a).each do |insn|
%   next if unsupported_insns.include?(insn.name)
  case BIN(<%= insn.name %>):
%   # Instruction-specific behavior in JIT
%   case insn.name
%   when 'opt_send_without_block', 'send'
<%=   render 'mjit_compile_send', locals: { insn: insn } -%>
%   when 'opt_aref' # experimental. TODO: increase insns and make the list automatically by finding DISPATCH_ORIGINAL_INSN
<%=   render 'mjit_compile_send', locals: { insn: opt_send_without_block } -%>
%   when 'leave'
    if (b->stack_size != 1) {
        if (mjit_opts.warnings || mjit_opts.verbose)
            fprintf(stderr, "MJIT warning: Unexpected JIT stack_size on leave: %d\n", b->stack_size);
        status->success = FALSE;
    }
%   when 'invokeblock'
    fprintf(f, "{\n");
    {
        MAYBE_UNUSED(CALL_INFO ci) = (CALL_INFO)operands[0];
        if (status->local_stack_p) {
            fprintf(f, "    MAYBE_UNUSED(unsigned int) stack_size = %u;\n", b->stack_size);
        }
        fprintf(f, "    MAYBE_UNUSED(CALL_INFO) ci;\n");
        fprintf(f, "    MAYBE_UNUSED(VALUE) val;\n");

        fprintf(f, "    ci = (CALL_INFO)0x%"PRIxVALUE";", operands[0]);
        comment_id(f, ((CALL_INFO)operands[0])->mid);
        fprintf(f, "\n");

<%= render 'mjit_compile_pc_and_sp', locals: { insn: insn } -%>

        fprintf(f, "    {\n");
        fprintf(f, "        struct rb_calling_info calling;\n");
        fprintf(f, "        VALUE block_handler;\n");

        fprintf(f, "        calling.argc = ci->orig_argc;\n");
        fprintf(f, "        calling.block_handler = VM_BLOCK_HANDLER_NONE;\n");
        fprintf(f, "        calling.recv = Qundef; /* should not be used */\n");

        fprintf(f, "        block_handler = VM_CF_BLOCK_HANDLER(GET_CFP());\n");
        fprintf(f, "        if (block_handler == VM_BLOCK_HANDLER_NONE) {\n");
        fprintf(f, "            rb_vm_localjump_error(\"no block given (yield)\", Qnil, 0);\n");
        fprintf(f, "        }\n");

        fprintf(f, "        val = vm_invoke_block(ec, GET_CFP(), &calling, ci, block_handler);\n");

        if (status->iseq_for_pos != NULL && (void *)(status->iseq_for_pos[pos]) != NULL && !(status->iseq_for_pos[pos]->catch_except_p)) {
            fprintf(f, "        if (val == Qundef) {\n");
            fprintf(f, "            if (LIKELY(ec->cfp->iseq->body == 0x%"PRIxVALUE")) {\n", (VALUE)status->iseq_for_pos[pos]);
            fprintf(f, "                val = _mjit_yielded_%d(ec, ec->cfp);\n", pos);
            fprintf(f, "            }\n");
            fprintf(f, "            else {\n");
            fprintf(f, "                EXEC_EC_CFP(val);\n");
            fprintf(f, "            }\n");
            fprintf(f, "        }\n");
        }
        else {
            fprintf(f, "        if (val == Qundef) {\n");
            fprintf(f, "            EXEC_EC_CFP(val);\n");
            fprintf(f, "        }\n");
        }

        fprintf(f, "    }\n");
        fprintf(f, "    stack[%d] = val;\n", b->stack_size + (int)attr_sp_inc_invokeblock(ci) - 1);

        fprintf(f, "    if (UNLIKELY(ruby_vm_event_enabled_flags & ISEQ_TRACE_EVENTS)) {\n");
        fprintf(f, "        reg_cfp->sp = (VALUE *)reg_cfp->bp + %d;\n", b->stack_size + (int)attr_sp_inc_invokeblock(ci) + 1);
        if (!body->catch_except_p) {
            fprintf(f, "        reg_cfp->pc = original_body_iseq + %d;\n", next_pos);
        }
        fprintf(f, "        goto cancel;\n");
        fprintf(f, "    }\n");

        b->stack_size += attr_sp_inc_invokeblock(ci);
    }
    fprintf(f, "}\n");
    break;
%   end
%
%   # Main insn implementation generated by insns.def
<%= render 'mjit_compile_insn', locals: { insn: insn, dispatched: false } -%>
    break;
% end
%
% # We don't support InstructionsUnifications yet because it's not used for now.
% # We don't support TraceInstructions yet. There is no blocker for it but it's just not implemented.
  default:
    if (mjit_opts.warnings || mjit_opts.verbose)
        fprintf(stderr, "MJIT warning: Skipped to compile unsupported instruction: %s\n", insn_name(insn));
    status->success = FALSE;
    break;
}
