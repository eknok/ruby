% # -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*-
% # Copyright (c) 2018 Takashi Kokubun.  All rights reserved.
% #
% # This file is a part of  the programming language Ruby.  Permission is hereby
% # granted, to either  redistribute and/or modify this file,  provided that the
% # conditions mentioned  in the  file COPYING  are met.   Consult the  file for
% # details.
%
% if insn.handles_frame?
        fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", next_pos); /* ADD_PC(INSN_ATTR(width)); */
        fprintf(f, "    reg_cfp->sp = (VALUE *)reg_cfp->bp + stack_size + 1 - <%= insn.pops.size %>;\n"); /* POPN(INSN_ATTR(popn)); */
%
%       # JIT-only behavior (pushing JIT's local variables to VM's stack):
        {
            rb_snum_t i, push_size;
            push_size = -<%= insn.call_attribute('sp_inc') %> + <%= insn.rets.size %> - <%= insn.pops.size %>;
            for (i = 0; i < push_size; i++) { /* TODO: use memcpy? */
                fprintf(f, "    *(reg_cfp->sp + %ld) = stack[%ld];\n", i - push_size, (rb_snum_t)b->stack_size - push_size + i);
            }
        }
% else
        fprintf(f, "    reg_cfp->pc = original_body_iseq + %d;\n", pos);
%   # sp motion is optimized away for this case. sp should be set properly before `goto cancel` or longjmp.
% end
